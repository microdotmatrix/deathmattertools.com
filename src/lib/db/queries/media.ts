import "server-only";

import {
  entryImagesTag,
  userGeneratedImagesTag,
  userImagesTag,
} from "@/lib/cache";
import { db } from "@/lib/db";
import { UserGeneratedImageTable, UserUploadTable } from "@/lib/db/schema";
import { auth } from "@clerk/nextjs/server";
import { and, count, desc, eq } from "drizzle-orm";
import { cacheLife, cacheTag } from "next/cache";

// ============================================================================
// User Generated Images Queries
// ============================================================================

/**
 * Fetches epitaph IDs for images generated by a specific user
 * @param userId User ID to fetch epitaph IDs for
 * @returns Array of epitaph IDs
 */
export async function getUserGeneratedEpitaphIds(userId: string) {
  "use cache";
  cacheLife("dashboard");
  cacheTag(userImagesTag(userId));

  const generatedImages = await db.query.UserGeneratedImageTable.findMany({
    where: eq(UserGeneratedImageTable.userId, userId),
    orderBy: (images, { desc }) => [desc(images.createdAt)],
  });

  return generatedImages.map((image) => image.epitaphId);
}

/**
 * Counts user generated images for a specific entry
 * Optimized for dashboard stats - only returns count, not full records
 * @param userId User ID to count images for
 * @param entryId Entry ID to count images for
 * @returns Count of generated images
 */
export async function getUserGeneratedImagesCount(
  userId: string,
  entryId: string
) {
  "use cache";
  cacheLife("dashboard");
  cacheTag(userGeneratedImagesTag(userId, entryId));

  const result = await db
    .select({ count: count() })
    .from(UserGeneratedImageTable)
    .where(
      and(
        eq(UserGeneratedImageTable.userId, userId),
        eq(UserGeneratedImageTable.entryId, entryId)
      )
    );

  return result[0]?.count ?? 0;
}

/**
 * Fetches all user generated images from the database
 * @param userId User ID to fetch generated images for
 * @param entryId Entry ID to fetch images for
 * @returns Array of user generated images or empty array if none found
 */
export async function getUserGeneratedImages(userId: string, entryId: string) {
  "use cache";
  cacheLife("content");
  cacheTag(userGeneratedImagesTag(userId, entryId));

  const generatedImages = await db.query.UserGeneratedImageTable.findMany({
    where: and(
      eq(UserGeneratedImageTable.userId, userId),
      eq(UserGeneratedImageTable.entryId, entryId)
    ),
    orderBy: (images, { desc }) => [desc(images.createdAt)],
  });

  return generatedImages;
}

/**
 * Fetches paginated user generated images
 * Recommended for large image collections to avoid memory issues
 * @param userId User ID to fetch images for
 * @param entryId Entry ID to fetch images for
 * @param page Page number (1-indexed)
 * @param pageSize Number of images per page
 * @returns Paginated array of user generated images
 */
export async function getUserGeneratedImagesWithPagination(
  userId: string,
  entryId: string,
  page: number = 1,
  pageSize: number = 6
) {
  "use cache";
  cacheLife("content");
  cacheTag(userGeneratedImagesTag(userId, entryId));

  const generatedImages = await db
    .select()
    .from(UserGeneratedImageTable)
    .where(
      and(
        eq(UserGeneratedImageTable.userId, userId),
        eq(UserGeneratedImageTable.entryId, entryId)
      )
    )
    .orderBy(desc(UserGeneratedImageTable.createdAt))
    .limit(pageSize)
    .offset((page - 1) * pageSize);

  return generatedImages;
}

// ============================================================================
// Entry Images (User Uploads) Queries
// ============================================================================

/**
 * Internal cached query for entry images by user and entry
 * Separates auth from cached data for proper caching behavior
 */
async function getEntryImagesCached(userId: string, entryId: string) {
  "use cache";
  cacheLife("content");
  cacheTag(entryImagesTag(entryId));

  const images = await db
    .select()
    .from(UserUploadTable)
    .where(
      and(
        eq(UserUploadTable.userId, userId),
        eq(UserUploadTable.entryId, entryId)
      )
    )
    .orderBy(UserUploadTable.createdAt);

  return images;
}

/**
 * Public wrapper that handles auth before calling cached query
 * @param entryId Entry ID to fetch images for
 * @returns Object with success/images or error
 */
export async function getEntryImages(entryId: string) {
  const { userId } = await auth();

  if (!userId) {
    return { error: "Unauthorized" };
  }

  try {
    const images = await getEntryImagesCached(userId, entryId);
    return { success: true, images };
  } catch (error) {
    console.error("Failed to get images:", error);
    return { error: "Failed to get images" };
  }
}