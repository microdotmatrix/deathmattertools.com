import { cache as unstableCache, TAGS } from "@/lib/cache";
import { db } from "@/lib/db";
import { UserGeneratedImageTable, UserUploadTable } from "@/lib/db/schema";
import { auth } from "@clerk/nextjs/server";
import { and, count, desc, eq } from "drizzle-orm";
import { cache } from "react";

/**
 * Fetches epitaph IDs for images generated by a specific user
 * Uses React cache() for request-level deduplication only (no persistence)
 * @param userId User ID to fetch epitaph IDs for
 * @returns Array of user generated images with their epitaph IDs
 */
export const getUserGeneratedEpitaphIds = cache(async (userId: string) => {
  // Fetch all generated images for this user
  const generatedImages = await db.query.UserGeneratedImageTable.findMany({
    where: eq(UserGeneratedImageTable.userId, userId),
    orderBy: (images, { desc }) => [desc(images.createdAt)],
  });

  // Return the epitaph IDs
  return generatedImages.map((image) => image.epitaphId);
});

/**
 * Counts user generated images for a specific entry
 * Optimized for dashboard stats - only returns count, not full records
 * Small data size - safe to cache with unstable_cache
 * @param userId User ID to count images for
 * @param entryId Entry ID to count images for
 * @returns Count of generated images
 */
export const getUserGeneratedImagesCount = unstableCache(
  async (userId: string, entryId: string) => {
    const result = await db
      .select({ count: count() })
      .from(UserGeneratedImageTable)
      .where(
        and(
          eq(UserGeneratedImageTable.userId, userId),
          eq(UserGeneratedImageTable.entryId, entryId)
        )
      );

    return result[0]?.count ?? 0;
  },
  [TAGS.userGeneratedImages],
  { revalidate: 60, tags: [TAGS.userGeneratedImages] }
);

/**
 * Fetches all user generated images from the database
 * Uses React cache() for request-level deduplication only
 * IMPORTANT: Does NOT use unstable_cache - image data is too large (>2MB)
 * @param userId User ID to fetch generated images for
 * @param entryId Entry ID to fetch images for
 * @returns Array of user generated images or empty array if none found
 */
export const getUserGeneratedImages = cache(
  async (userId: string, entryId: string) => {
    // Fetch all generated images for this user
    const generatedImages = await db.query.UserGeneratedImageTable.findMany({
      where: and(
        eq(UserGeneratedImageTable.userId, userId),
        eq(UserGeneratedImageTable.entryId, entryId)
      ),
      orderBy: (images, { desc }) => [desc(images.createdAt)],
    });

    return generatedImages;
  }
);

/**
 * Fetches paginated user generated images
 * Uses React cache() for request-level deduplication only
 * Recommended for large image collections to avoid memory issues
 * @param userId User ID to fetch images for
 * @param entryId Entry ID to fetch images for
 * @param page Page number (1-indexed)
 * @param pageSize Number of images per page
 * @returns Paginated array of user generated images
 */
export const getUserGeneratedImagesWithPagination = cache(
  async (
    userId: string,
    entryId: string,
    page: number = 1,
    pageSize: number = 6
  ) => {
    const generatedImages = await db
      .select()
      .from(UserGeneratedImageTable)
      .where(
        and(
          eq(UserGeneratedImageTable.userId, userId),
          eq(UserGeneratedImageTable.entryId, entryId)
        )
      )
      .orderBy(desc(UserGeneratedImageTable.createdAt))
      .limit(pageSize)
      .offset((page - 1) * pageSize);

    return generatedImages;
  }
);

export const getEntryImages = async (entryId: string) => {
  const { userId } = await auth();

  if (!userId) {
    return { error: "Unauthorized" };
  }

  try {
    const images = await db
      .select()
      .from(UserUploadTable)
      .where(
        and(
          eq(UserUploadTable.userId, userId),
          eq(UserUploadTable.entryId, entryId)
        )
      )
      .orderBy(UserUploadTable.createdAt);

    return { success: true, images };
  } catch (error) {
    console.error("Failed to get images:", error);
    return { error: "Failed to get images" };
  }
};